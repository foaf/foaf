#!/usr/bin/ruby
# 
# section_util.rb - hypertext templating utilities
# author: Dan Brickley <danbri@w3.org>
# status: Work in progress. Parsing works; no rewriting yet. 
# see also: navtest1
#
# version: $Id: section_util.rb,v 1.3 2004-08-14 23:07:31 danbri Exp $
# Log:
#   $Log: not supported by cvs2svn $
#   Revision 1.2  2004/08/14 20:38:13  danbri
#   working on remaster script now
#
#   Revision 1.1  2004/08/14 19:45:07  danbri
#   coding
#
#
# Utility to parse files on FOAF site 
# It reads an HTML page from disk, 
# parses the commented sections into "sections" hashtable
#
# Basic idea is that bits of your HTML doc are marked up with 
# surrounding comments, such as:
#
# 	<!-- InstanceBeginEditable name="HelpText" -->
# 	<p>help yourself</p> 
# 	<!-- InstanceEndEditable -->
#
#  ...so each page implicit has a set of name/content pairs, 
#  where the name is something like "HelpText" or "CopyrightFooter" 
#  and the content is a chunk of (hopefully UTF-8) markup text.
#
#  The intent is that these utilities could allow for some of these 
#  bits of markup to be refreshed / rewritten based on the content of 
#  a "master" template stored elsewhere in the filetree. 
#
# IMPLEMENTATION:
# 
# The class DocFile represents an HTML file in the local tree.
#
# mydoc = DocFile.new('../files/mypage.html') # initialize
#
# redone = mydoc.scan  # parse and reserialize to text
#
# puts mydoc.sections['SecondaryNavigation'] # examine named bits
#
# 
# TODO:
# things to lookup in manual
# 1. 'find' functionality
# 2. 'load file to string'
# line 18 column 76 - Warning: nested emphasis <span>
# 

class DocFile

  def initialize(fn)
    if fn 
      @text = `cat #{fn}`
    else
      @text=''
    end
    @restrung='' # for result of parsing
    @remasters=[]
  end

  attr_accessor :text, :restrung, :sections, :defers_to, :remasters
  # :text is content of the doc
  # :restrung is the string serialization (re)generated by scan()
  # :sections is a Hash of named sections parsed from the HTML text
  # :defers_to references another master/template Document, from which scan() ...
  # :remasters an Array of selected sections, deferring to content from the 2nd doc.
  #  ...note that the rewriting functionality not implemented at time of this drafting.

  def title
    t=''
    text =~ /<title>([^<]*)<\/title/ # quick parse of title
    return $1
  end

  def refresh_from_master!
    return scan('rewrite')
  end

  def scan(mode='readonly')
  
    require 'html/htmltokenizer' # http://raa.ruby-lang.org/project/htmltokenizer/
    page = text.clone 
    #page.gsub(/\n/," ") # needless ?

    @sections = Hash.new
    @restrung=''
    current_section='' # All the text in this current commented section  
    current_section_name='' # The name given to the current commented section 
    in_section=false    

    tokenizer = HTMLTokenizer.new(page)

    while token = tokenizer.getNextToken
    # puts "\n# Token type is: "+token.class().to_s;

      # Check for HTML comments, including hidden Dreamweaver-style begin and end markers:
      #
      if token.class.to_s=="HTMLComment"
#        puts "\nBEGINCOMMENT #{token.to_s} ENDCOMMENT\n\n"
        mycomment = token.to_s.clone  # We got a comment...
        # <!-- InstanceBeginEditable name="SecondaryNavigation" -->
        if mycomment =~ /InstanceBeginEditable/
#          puts "# Found beginning of section...'"
           if in_section==true 
             STDERR.puts "Bad data? already in a section, found new section start. Continuing."
           end
           in_section = true
           current_section = '' # reset accumulated content
 
          mycomment =~ /name="([^"]*)"/
          if $1 
#            puts "# named section: '#{$1}'"
            current_section_name=$1
          else
#            puts "# anonymous section."
          end
#         STDERR.puts "EMITTING TOKEN: #{token.to_s} ///\n\n"
          @restrung += token.to_s # emit our (comment) tag as well as the markup it closed

        # <!-- InstanceEndEditable -->
        elsif mycomment =~ /InstanceEndEditable/

#          STDERR.puts "# Closed section. Storing content under sectionID: '#{current_section_name}'"
           if in_section == false
 #            STDERR.puts "Bad data? already outside section, but found end section marker.Continuing."
           end
           in_section = false

           sections[current_section_name] = current_section # stash this chunk against its name

	   # ...and reserialize it (unless it needs replacing from a defer_to)	

	   # A comment just closed, do we output our current_section accumulated content
	   # OR DO WE OUTPUT deferred content from the master template we :defer_to ?
	   # below, we only output stuff when we're not in a section.
 

          if ((mode=='rewrite') && self.remasters.member?(current_section_name))

#            STDERR.puts "WE SHOULD BE REMASTERING THIS SECTION: #{current_section_name}  "

            if self.defers_to.sections[current_section_name]
              # we're remastering this bit, and we have the content 
              mtxt = self.defers_to.sections[current_section_name]
 #              @restrung += "<!-- new text is: [[[ #{mtxt} ]]] -->\n\n"
 #             STDERR.puts("REWORKING: new is #{mtxt} ") # xxxd

              @restrung += "<!-- new: -->#{mtxt}<!-- :endnew --> " # serialize the replacement text 
              current_section = '' # reset current text to avoid later respew
            else
              #puts "BUT WE CAN'T FIND IT. (throw exception?)"
            end
          else
             # we're not remastering this section
             current_section.gsub!(/\r/," ")
          end

#          @restrung += token.to_s # emit our (comment) tag as well as the markup it closed
	  current_section=''
          current_section_name='' # otherwise when next hit an end, might refire.

        # Add recognition of other Dreamweaver MX tags here?:
        # elsif mycomment =~ / .... /
        # elsif mycomment =~ / .... /
        else 
#          puts "# Normal HTML comment? ie. unrecognised. moving on..."
        end

        # pass thru the comment tagging

        if (in_section == false)
          out=token.to_s
          out.gsub!(/\r/," ")
          @restrung += "#{out}" # danbrizzz
        else 
          # we're in a section, and accumulating content
          # nothing to do here; it happens when a section closes (above)
        end

        # end comment processing

      else
        out=token.to_s
        out.gsub!(/\r/," ")
        # STDERR.puts "MY CHUNK: [[[ #{out} ]]]\n\n\n" #zzzzz
        current_section += out # other tokens get appended to current accumulation
        @restrung += out unless in_section # suppress output in case refreshing from master
      end
    end # done HTML parsing

    return @restrung    

  end


  def section_debug
    txt=''
    txt += "############# DUMPING MARKED SECTIONS:\n\n" 
    sections.each do  |a,b| txt += "#{a} --->>>> #{b.gsub(/\r/," ")} \n\n" end
    txt += "############# END MARKED SECTION DUMP.\n\n\n" 
   return txt
  end

end # Class definition

###############################################################################

